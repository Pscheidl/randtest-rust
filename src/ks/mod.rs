use ::RndTest;
use ::RndTestResult;
use std::cmp::Ordering;
use rgsl::randist::gaussian::ugaussian_Pinv;
use std::ops::IndexMut;
use std::ops::Index;

pub struct KolmogorovSmirnovTestResult {
	pub criteria: f64,
	num_values: usize
}

impl RndTestResult for KolmogorovSmirnovTestResult{
	fn is_random(&self, alpha: f64) -> bool{
		let critical: f64 = ((1f64/(2f64 * self.num_values as f64)) * (2f64 / alpha).ln()).sqrt();
		return self.criteria < critical;
	}
}

///Tests if given random numbers are generated by generator
///with uniform distribution.
pub struct KolmogorovSmirnovTest{
	pub rnd_values: Vec<f64>,
	pub lower_bound: f64,
	pub upper_bound: f64,
	pub num_intervals: u8
}

impl RndTest<KolmogorovSmirnovTestResult> for KolmogorovSmirnovTest{
	fn test(&self) -> KolmogorovSmirnovTestResult{
		let mut intervals: Vec<Interval> = split_intervals(self.lower_bound, self.upper_bound, self.num_intervals);
		count_empirical_freq(&self.rnd_values, &mut intervals);
		let theoretical_per_interval: f64 = (self.rnd_values.len() as f64 /  self.num_intervals as f64).floor();


		let mut cumulative_freq: Vec<f64> = Vec::with_capacity(intervals.len());
		for index in 0..intervals.len() as usize {
			if index > 0 {
				let previous_freq = cumulative_freq[index - 1];
				cumulative_freq.push(previous_freq +  ((theoretical_per_interval -  intervals[index].frequency as f64) / self.rnd_values.len() as f64));
			} else {
				cumulative_freq.push(intervals[index].frequency as f64 / self.rnd_values.len() as f64);
			}
		}

		let max = find_max_abs(&cumulative_freq);

		KolmogorovSmirnovTestResult{
			criteria: max,
			num_values: self.rnd_values.len()
		}
	}
}

struct Interval{
	from: f64,
	to:f64,
	frequency: u64
}

fn split_intervals(lower_bound: f64, upper_bound: f64, num_intervals: u8) -> Vec<Interval>{
	let mut intervals: Vec<Interval> = Vec::with_capacity(num_intervals as usize);

	if upper_bound <= lower_bound {
		panic!("Upper & lower bound for Kolmogorov-Smirnov test need not be the same.");
	}

	let interval_len : f64 = (upper_bound - lower_bound) as f64 / num_intervals as f64;
	let mut current_lower_bound: f64 = lower_bound;

	while current_lower_bound < upper_bound {
		intervals.push(Interval{from: current_lower_bound, to: current_lower_bound + interval_len, frequency: 0});
		current_lower_bound += interval_len;
	}

	intervals
}

fn count_empirical_freq(rnd_values: &Vec<f64>, intervals: &mut Vec<Interval>){
	let mut sorted_rnd_values : Vec<f64> = rnd_values.clone();
	sorted_rnd_values.sort_by(|a,b| {
		if a < b {
			return Ordering::Less;
		} else if a > b {
			return Ordering::Greater;
		} else {
			return Ordering::Equal;
		}
	});

	let mut thresholds: Vec<f64> = Vec::with_capacity(intervals.len());

	for interval in intervals.into_iter(){
		thresholds.push(interval.to.clone());
	}
	let mut current_threshold_index : usize = 0;

	for value in sorted_rnd_values{
		if value > thresholds[current_threshold_index] {
			current_threshold_index += 1;
		}
		intervals.index_mut(current_threshold_index).frequency += 1;
	}

}

fn find_max_abs(values: &Vec<f64>) -> f64{
	let mut maximum = 0f64;

	for val in values{
		if val.abs() > maximum{
			maximum = val.clone();
		}
	}
	maximum
}





